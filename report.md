# 큰 수 곱셈 과제 보고서

## 1. 과제 목표

일반적인 32비트 정수형으로 표현할 수 없는 큰 수(100,000 x 100,000)를 곱하는 C 함수 `big_mult()`를 직접 구현하고, 그 결과를 16진수로 출력하는 것을 목표로 합니다.

## 2. 코드 설명

### 2.1. 큰 수 표현 방식

큰 수를 효율적으로 다루기 위해 C언어의 기본 자료형이 아닌 **문자열(char 배열)**을 사용하여 숫자를 표현했습니다. 배열의 각 요소는 숫자의 한 자릿수를 의미합니다. 예를 들어, 숫자 123은 문자열 "123"으로 저장됩니다.

### 2.2. 핵심 함수 로직

#### `big_mult(const char *num1, const char *num2)`
두 개의 큰 수 문자열을 곱하는 메인 함수입니다. 초등학교에서 배운 세로셈 곱셈 원리를 그대로 코드로 구현했습니다.

1.  `num2`의 각 자릿수를 하나씩 가져옵니다.
2.  해당 자릿수와 `num1` 전체를 곱합니다. (`multiply_by_digit` 함수 사용)
3.  `num2`의 자릿수 위치에 맞게 중간 결과값의 뒤에 '0'을 추가하여 자릿수를 맞춰줍니다.
4.  이렇게 계산된 중간 결과들을 모두 더하여(`big_add` 함수 사용) 최종 곱셈 결과를 구합니다.

#### `decToHex(char* dec)`
곱셈 결과로 나온 10진수 문자열을 16진수 문자열로 변환합니다. 이는 10진법의 숫자를 16진법으로 변환하는 표준적인 알고리즘(반복적인 나눗셈)을 문자열 기반 큰 수 연산으로 구현한 것입니다.

1.  **반복 나눗셈:** 입력된 10진수 문자열이 "0"이 될 때까지 `divide_string(current_dec, 16, &remainder)` 함수를 사용하여 16으로 나누는 과정을 반복합니다.
2.  **나머지 사용:** 매 나눗셈에서 발생하는 **나머지(remainder)** 값(0~15)을 16진수 문자(`0`~`F`)로 변환합니다.
3.  **자릿수 누적:** 이 나머지는 16진수의 낮은 자릿수부터 계산되므로, 결과 배열에 차례대로 저장한 뒤 마지막에 문자열 전체를 뒤집어 올바른 순서로 만듭니다.
4.  **몫 업데이트:** 나눗셈의 **몫(quotient)**을 다음 반복에서 나눌 숫자로 사용합니다. 몫이 "0"이 되면 반복을 종료합니다.

## 3. 컴파일 및 실행 방법

1.  **컴파일**: 터미널에서 아래 명령어를 실행하여 `main.c` 파일을 컴파일합니다.
    ```bash
    gcc main.c -o multiply
    ```

2.  **실행**: 컴파일 후 생성된 `multiply` 실행 파일을 실행합니다.
    ```bash
    ./multiply
    ```

## 4. 실행 결과 (Working Proof)

```
Multiplying 100000 x 100000
Decimal result: 10000000000
Hexadecimal result: 2540BE400
```

